#In this R script, we run haploid simulations using 
#Fisher's geometric model with different fitness curvatures in order
#to measure adaptation statistics, parallel evolution, and reproductive isolation

#Each population simulation is repeated 100 times for a range of different k values,
#with 60 fixation events per population. Then, for each set of populations associated with each k value,
#and for each number of fixation events, F1 hybrids are generated for all possible
#population pairs, and adaptation/hybridization statistics are recorded. This process is then denoted a "run", and
#is repeated 50 times, each time with a new mutational library.

#This file requires haploid_diffcalc.cpp and haploid_sim.cpp, with their respective functions,
#to be in the working directory

library(tidyverse)
library(Rcpp)
sourceCpp("haploid_diffcalc.cpp")
sourceCpp("haploid_sim.cpp")

#A simple function to create a "library" of mutational vectors to be used by a 
#population for adaptation.
#Inputs:
#l: the number of mutations required (or the number of loci contributing to adaptation)
#n: the number of trait dimensions
#lambda: the average effect size of the mutations
#Returns:
#An l x n matrix, with each row representing a different mutation vector and each column
#representing a trait dimension
createMutationLibrary<- function(l,n,lambda){ 
  library <- NULL
  for(i in 1:l){
    base <- rnorm(n)
    size <- rexp(1,r=1/lambda)
    mut <- base*size
    library <- rbind(library,mut)
  }
  return(library)
}

#Here we allow some population parameters to be 
#defined over the command line
args <- commandArgs(TRUE)
#number of loci contributing to adaptation
l <- as.numeric(args[2])
#the average effect size (mean parameter for exponential draw)
lambda <- as.numeric(args[3])

#Number of individuals in each population
N <- 1000
#Number of trait dimensions under consideration
n <- 5
#The number of fixation events required for each simulation to end
endpoint <- 60
#The number of populations associated with a given mutation library and k value
num_pops <- 100
#The number of simulation "runs", see begining of file
num_runs <- 50

#Data frame to store adaptation parameters and results we will record during simulations
#lambda: the mutational effect size
#k: the k parameter for the fitness function
#i: a population index for identifying populations adapted to a given k value and mutation library
#run: the run number, which references the mutation library the population adapted to
#fitnesses: the fitnesses of a population at each fixation event during the simulation
#order: the list of of mutations fixed (or unfixed) at each fixation event during the simulation,
# is a list of integers refering to loci
#s: the selection coefficients of each fixed mutation
#distances: the distance of the population from the environmental optimum after
# each fixation event during the simulation
#l: the number of loci contributing to adaptation
run_data <- tibble(
  lambda=numeric(),
  k=numeric(),
  i=numeric(),
  run=numeric(),
  fitnesses=list(),
  order=list(),
  s=list(),
  distances=list(),
  l=numeric()
)

#This is a data frame that stores F1 hybrid statistics, and relevent parental population statistics,
#for each set of populations adapted to each mutation library and k value

#generation: the number of fixation events that have passed
#l: the number of loci contributing to adaptation
#lambda: the average mutational effect size
#k: the k parameter for the fitness function
#run: the run number, referring to the mutation library the population set adapted to
#mean_mutational: the average proportion of fixed mutations between any two populations
#mean_overall: the average proportion of the genome that is identical between any two populations
#mean_common_distance: the average distance to the optimum only considering common mutations
#between any two populations
#mean_F1_fitness: the average F1 hybrid fitness from hybrids generated by any two populations
#mean_F1_distance: the average F1 distance to the optimum from hybrids generated by any two populations
#mean_parental_fitness: the average parental populations fitness
#mean_parental_distance: the average distance to the optimum by any parental population
diff_tibble <- tibble(generation=integer(),
                      l=numeric(),
                      lambda=numeric(),
                      k=numeric(),
                      run=numeric(),
                      mean_mutational=numeric(),
                      mean_overall=numeric(),
                      mean_common_distance=numeric(),
                      mean_F1_fitness=numeric(),
                      mean_F1_distance=numeric(),
                      mean_parental_fitness=numeric(),
                      mean_parental_distance=numeric())

#Set the seed for reproducability. We make this a function of l and lambda, as
#in the experimental context these are what change between implementations of this script
set.seed(l+lambda*1000)

#The actual experiment, which we repeat num_runs times
for(run in 1:num_runs){
  #Create the mutation library used by the simulated populations in this run, save as a csv file
  library_matrix <- createMutationLibrary(l,n,lambda)
  write_csv(as.data.frame(library_matrix),paste("library",l,lambda,run,".csv",sep="_"))
  #repeat these population simulations with the same mutational library for a range of k values
  for(k in c(2,4,6,8,10)){
    parental_fitnesses <- vector("list",num_pops)
    orders <- vector("list",num_pops)
    distances <- vector("list",num_pops)
    #repeate population simulations num_pops times
    for(i in 1:num_pops){
      #The actual population sim, see haploid_sim.cpp for documentation.
      sim <-  haploid_sim(library_matrix,c(2.0,0.0,0.0,0.0,0.0),k,N,l,n,integer(0),numeric(0),numeric(0),numeric(0),endpoint,rdunif(1,.Machine$integer.max,0))
      orders[[i]] <- sim$order
      parental_fitnesses[[i]] <- sim$fitnesses
      distances[[i]] <- sim$distances
      ss <- list(sim$s)
      #Record population simulation statistics and results
      run_data <- run_data %>%
        add_row(lambda=lambda,k=k,i=i,run=run,
                fitnesses=list(parental_fitnesses[[i]]),
                order=list(orders[[i]]),
                distances=list(distances[[i]]),
                s=ss,
                l=l)
    }
    
    #For each simulated population in this population set 
    #and for each number of fixation events, generate F1
    #hybrids and measure their adaptation statistics
    for(i in 1:endpoint){
      #eliminate all fixation events past the desired number of fixation events in all populations
      new_orders <- lapply(orders,function(X){
        x <- unlist(X)
        return(x[1:i])
      })
      #Generate F1 hybrids and record their statistics. see haploid_diffcalc.cpp for documentation
      results <- mutational_differences(new_orders,library_matrix,c(2.0,0.0,0.0,0.0,0.0),l,n,k,rdunif(1,.Machine$integer.max,0))
      diff_tibble <- diff_tibble %>%
        add_row(l=l,lambda=lambda,k=k,run=run,
                mean_mutational=results$mean_mutational,
                mean_overall=results$mean_overall,
                mean_common_distance=results$mean_common_distance,
                mean_F1_fitness=results$mean_F1_fitness,
                mean_F1_distance=results$mean_F1_distance,
                mean_parental_fitness=mean(unlist(lapply(parental_fitnesses,function(X){return(unlist(X)[i])}))),
                mean_parental_distance=mean(unlist(lapply(distances,function(X){return(unlist(X)[i])}))),
                generation=i)
    }
  }
}
#Write all adaptation data to an rds file, and all F1 hybrid data to a common csv file
write_rds(run_data,paste("data_",lambda,"_",l,".rds",sep=""))
if(file.exists("diffs_at_index.csv")){
  write_csv(diff_tibble,"diffs_at_index.csv",append=TRUE)
} else {
  write_csv(diff_tibble,"diffs_at_index.csv")
}


